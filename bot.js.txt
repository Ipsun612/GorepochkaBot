require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const { GoogleGenerativeAI } = require("@google/generative-ai");
const { transcribeAudio } = require('./speechProcessor'); // <-- –ü–û–î–ö–õ–Æ–ß–ê–ï–ú –ù–ê–® –ú–û–î–£–õ–¨
const cors =require('cors');
const fs = require('fs');
const path = require('path');
const axios = require('axios');

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Google Gemini API
if (!process.env.GEMINI_API_KEY) {
    console.error('‚ùå –û—à–∏–±–∫–∞: GEMINI_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ.');
    process.exit(1);
}
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// –ò—Å–ø–æ–ª—å–∑—É–µ–º –†–ê–ë–û–ß–£–Æ –º–æ–¥–µ–ª—å. –û–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏ —Ç–µ–∫—Å—Ç, –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –∏ –∞—É–¥–∏–æ.
const GEMINI_MODEL_NAME = process.env.GEMINI_MODEL_NAME || "gemini-2.5-flash"; 
console.log(`üß† –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–æ–¥–µ–ª—å: ${GEMINI_MODEL_NAME}`);

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
const HISTORY_DIR = path.join(__dirname, 'history');
const IMAGES_DIR = path.join(__dirname, 'images');
if (!fs.existsSync(HISTORY_DIR)) fs.mkdirSync(HISTORY_DIR);
if (!fs.existsSync(IMAGES_DIR)) fs.mkdirSync(IMAGES_DIR);

// –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∏ –≤–µ—Ä–Ω—ã –¥–ª—è –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º—ã.
const WELCOME_MESSAGE_PATH = 'C:/Users/Shilova/Desktop/MySeksGorepochka/Logs/FirstMessage.txt';
const CHANGELOG_PATH = 'C:/Users/Shilova/Desktop/MySeksGorepochka/Logs/ChangeLog.txt';

console.log(`‚ÑπÔ∏è –ü—É—Ç—å –∫ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–º—É —Å–æ–æ–±—â–µ–Ω–∏—é: ${WELCOME_MESSAGE_PATH}`);
console.log(`‚ÑπÔ∏è –ü—É—Ç—å –∫ –ª–æ–≥—É –∏–∑–º–µ–Ω–µ–Ω–∏–π: ${CHANGELOG_PATH}`);


let welcomeMessage = '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.';
try {
    welcomeMessage = fs.readFileSync(WELCOME_MESSAGE_PATH, 'utf8');
    console.log('‚úÖ –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ —Ñ–∞–π–ª–∞');
} catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è: ${error.message}`);
    console.log('‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ');
}

let systemPrompt = '';
try {
    const PROMPT_FILE_PATH = path.join(__dirname, 'Prompts/Gorepochka/gorepochka.txt');
    systemPrompt = fs.readFileSync(PROMPT_FILE_PATH, 'utf8');
    console.log('‚úÖ –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –∑–∞–≥—Ä—É–∂–µ–Ω');
} catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–º–ø—Ç–∞: ${error.message}`);
}

const chatHistories = {};
const userStates = {};
const MAX_CHAT_SLOTS = 8;

function getDefaultSlotState() {
    return {
        interactions: 0,
        lastActive: 0,
        contextSize: 0,
        spamCounter: 0,
        // –ù–æ–≤–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –æ—Ç–Ω–æ—à–µ–Ω–∏–π
        relationshipLevel: 0, 
        // +++ –î–û–ë–ê–í–õ–ï–ù–û: –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
        relationshipStatus: '–ù–µ–∑–Ω–∞–∫–æ–º–µ—Ü', 
        stressLevel: 0,
        isBanned: false,
        ignoreTimer: null,
        ignoreState: 'default'
    };
}

function initializeUser(chatId) {
    if (!userStates[chatId]) {
        userStates[chatId] = {
            hasCompletedWelcome: false,
            activeChatSlot: 0,
            slots: Array(MAX_CHAT_SLOTS).fill(null).map(() => getDefaultSlotState()),
        };
    }
    if (!chatHistories[chatId]) {
        chatHistories[chatId] = Array(MAX_CHAT_SLOTS).fill(null).map(() => []);
    }
}

function getChatHistoryPath(chatId, slotIndex) {
    return path.join(HISTORY_DIR, `${chatId}_slot_${slotIndex}.json`);
}

function loadChatHistory(chatId, slotIndex) {
    const filePath = getChatHistoryPath(chatId, slotIndex);
    if (fs.existsSync(filePath)) {
        try {
            return JSON.parse(fs.readFileSync(filePath, 'utf8'));
        } catch (e) {
            console.error(`‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ ${chatId}_slot_${slotIndex}:`, e.message);
            return [];
        }
    }
    return [];
}

function saveChatHistory(chatId, slotIndex, history) {
    const filePath = getChatHistoryPath(chatId, slotIndex);
    fs.writeFileSync(filePath, JSON.stringify(history, null, 2));
}

function clearChatHistoryAndState(chatId, slotIndex) {
    const filePath = getChatHistoryPath(chatId, slotIndex);
    if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
    if (chatHistories[chatId] && chatHistories[chatId][slotIndex]) {
        chatHistories[chatId][slotIndex] = [];
    }
    if (userStates[chatId] && userStates[chatId].slots[slotIndex]) {
        userStates[chatId].slots[slotIndex] = getDefaultSlotState();
    }
}

if (!process.env.TELEGRAM_BOT_TOKEN) {
    console.error('‚ùå –û—à–∏–±–∫–∞: TELEGRAM_BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ.');
    process.exit(1);
}
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });
console.log('ü§ñ –ë–æ—Ç Telegram –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');

const app = express();
app.use(cors());
app.use(express.json());
app.get('/', (req, res) => {
    res.send('Telegram LLM Bot —Å Google Gemini API —Ä–∞–±–æ—Ç–∞–µ—Ç!');
});

async function isChatValid(chatId) {
    try {
        const chat = await bot.getChat(chatId);
        return chat && !chat.pinned_message;
    } catch (error) {
        if (error.response?.body?.error_code === 403) {
            console.error(`‚ùå –ß–∞—Ç ${chatId} –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞)`);
            if (userStates[chatId]) delete userStates[chatId];
            if (chatHistories[chatId]) delete chatHistories[chatId];
            return false;
        }
        console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∞—Ç–∞ ${chatId}:`, error.message);
        return false;
    }
}

async function sendRelationshipStats(bot, chatId, slotState) {
    if (!slotState) return;
    // +++ –ò–ó–ú–ï–ù–ï–ù–û: –¢–µ–ø–µ—Ä—å –º—ã –±–µ—Ä–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞–ø—Ä—è–º—É—é –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –∞ –Ω–µ –≤—ã—á–∏—Å–ª—è–µ–º –µ–≥–æ.
    const statsMessage = `–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–ß–∞—Ç ${userStates[chatId] ? userStates[chatId].activeChatSlot + 1 : 'N/A'}):
  –£—Ä–æ–≤–µ–Ω—å –æ—Ç–Ω–æ—à–µ–Ω–∏–π: ${slotState.relationshipLevel} (${slotState.relationshipStatus})
  –°—Ç—Ä–µ—Å—Å: ${slotState.stressLevel}`;
    try {
        if (!(await isChatValid(chatId))) return;
        await bot.sendMessage(chatId, statsMessage);
        console.log(`üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –¥–ª—è —á–∞—Ç–∞ ${chatId}, —Å–ª–æ—Ç ${userStates[chatId] ? userStates[chatId].activeChatSlot : 'N/A'}`);
    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (${chatId}):`, error.message);
    }
}

bot.on('callback_query', async (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const data = callbackQuery.data;
    try {
        if (!(await isChatValid(chatId))) return;
        initializeUser(chatId);
        if (data === 'start_chat') {
            userStates[chatId].hasCompletedWelcome = true;
            await bot.answerCallbackQuery(callbackQuery.id);
            await bot.sendMessage(chatId, `–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ —Å –±–æ—Ç–æ–º (–≤ —á–∞—Ç–µ 1/${MAX_CHAT_SLOTS}). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /chatlist –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥—Ä—É–≥–æ–≥–æ —á–∞—Ç–∞.`);
            console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${chatId} –Ω–∞–∂–∞–ª "–ù–∞—á–∞—Ç—å –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—Ç—å—Å—è"`);
        } else if (data.startsWith('switch_chat_')) {
            const slotIndex = parseInt(data.split('_')[2]);
            if (slotIndex >= 0 && slotIndex < MAX_CHAT_SLOTS) {
                userStates[chatId].activeChatSlot = slotIndex;
                if (chatHistories[chatId][slotIndex].length === 0 && fs.existsSync(getChatHistoryPath(chatId, slotIndex))) {
                    chatHistories[chatId][slotIndex] = loadChatHistory(chatId, slotIndex);
                }
                await bot.answerCallbackQuery(callbackQuery.id, { text: `–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –Ω–∞ —á–∞—Ç ${slotIndex + 1}` });
                await bot.sendMessage(chatId, `–í—ã –ø–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –Ω–∞ —á–∞—Ç ${slotIndex + 1}.`);
                console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${chatId} –ø–µ—Ä–µ–∫–ª—é—á–∏–ª—Å—è –Ω–∞ —á–∞—Ç ${slotIndex + 1}`);
            } else {
                await bot.answerCallbackQuery(callbackQuery.id, { text: '–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ —á–∞—Ç–∞', show_alert: true });
            }
        }
    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –≤ callback_query (${chatId}):`, error.message);
        try {
            await bot.answerCallbackQuery(callbackQuery.id, { text: '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞', show_alert: true });
        } catch (e) { /* ignore */ }
    }
});

// –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è
function extractAndRemoveCommands(text, slotState, isDebugMode) {
    let modifiedText = text;
    const patterns = [
        // +++ –ò–ó–ú–ï–ù–ï–ù–û: –î–∏–∞–ø–∞–∑–æ–Ω —Ç–µ–ø–µ—Ä—å –æ—Ç -100 –¥–æ 100
        { regex: /<–ü–æ–≤—ã—Å–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –æ—Ç–Ω–æ—à–µ–Ω–∏–π –Ω–∞ (\d+)>/g, action: (amount) => slotState.relationshipLevel = Math.min(100, slotState.relationshipLevel + parseInt(amount)) },
        { regex: /<–ü–æ–Ω–∏–∑–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –æ—Ç–Ω–æ—à–µ–Ω–∏–π –Ω–∞ (\d+)>/g, action: (amount) => slotState.relationshipLevel = Math.max(-100, slotState.relationshipLevel - parseInt(amount)) },
        
        // +++ –î–û–ë–ê–í–õ–ï–ù–û: –ù–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–º–µ–Ω—ã —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
        { regex: /<–ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –æ—Ç–Ω–æ—à–µ–Ω–∏–π –Ω–∞:\s*(.*?)>/g, action: (status) => slotState.relationshipStatus = status.trim() },

        // –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        { regex: /<–ü–æ–≤—ã—Å–∏—Ç—å —Å—Ç—Ä–µ—Å—Å –Ω–∞ (\d+)>/g, action: (amount) => slotState.stressLevel = Math.min(100, slotState.stressLevel + parseInt(amount)) },
        { regex: /<–ü–æ–Ω–∏–∑–∏—Ç—å —Å—Ç—Ä–µ—Å—Å –Ω–∞ (\d+)>/g, action: (amount) => slotState.stressLevel = Math.max(0, slotState.stressLevel - parseInt(amount)) },
        { regex: /<–î–∞—Ç—å –±–∞–Ω>/g, action: () => slotState.isBanned = true },
        { regex: /<–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ø—Ä–æ—â–∞–ª—Å—è>/g, action: () => { slotState.ignoreState = 'goodbye'; console.log(`–°—Ç–∞—Ç—É—Å –æ–¥–Ω–æ–≥–æ –∏–∑ —á–∞—Ç–æ–≤ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ 'goodbye'`); } },
        { regex: /<–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ —Å–µ—Ç–∏>/g, action: () => { slotState.ignoreState = 'default'; console.log(`–°—Ç–∞—Ç—É—Å –æ–¥–Ω–æ–≥–æ –∏–∑ —á–∞—Ç–æ–≤ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ 'default'`); } },
    ];

    patterns.forEach(pattern => {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ 'g' –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤—Å–µ—Ö –≤—Ö–æ–∂–¥–µ–Ω–∏–π
        const regex = new RegExp(pattern.regex.source, 'g');
        let match;
        while ((match = regex.exec(text)) !== null) {
            // match[1] - —ç—Ç–æ –∑–∞—Ö–≤–∞—á–µ–Ω–Ω–∞—è –≥—Ä—É–ø–ø–∞ (—Ü–∏—Ñ—Ä–∞ –∏–ª–∏ —Ç–µ–∫—Å—Ç —Å—Ç–∞—Ç—É—Å–∞)
            const value = match[1]; 
            pattern.action(value);
        }

        // –£–¥–∞–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –∏–∑ —Ç–µ–∫—Å—Ç–∞, –µ—Å–ª–∏ –Ω–µ –≤–∫–ª—é—á–µ–Ω —Ä–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏
        if (!isDebugMode) {
            modifiedText = modifiedText.replace(regex, '');
        }
    });

    // –û—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ—Ç –ª–∏—à–Ω–∏—Ö —Ç–µ–≥–æ–≤ –∏ –ø—Ä–æ–±–µ–ª–æ–≤, –µ—Å–ª–∏ –Ω–µ –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏
    if (!isDebugMode) {
        modifiedText = modifiedText.replace(/<.*?>/g, '');
        modifiedText = modifiedText.replace(/\s{2,}/g, ' ').trim();
    } else {
        modifiedText = modifiedText.trim();
    }

    return modifiedText;
}

bot.onText(/\/chatlist/, async (msg) => {
    const chatId = msg.chat.id;
    if (!(await isChatValid(chatId))) return;
    initializeUser(chatId); // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –µ–≥–æ —Å–ª–æ—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã

    const userState = userStates[chatId];
    const buttons = [];

    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–∞–∂–¥–æ–º—É —Å–ª–æ—Ç—É, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –¥–ª—è –Ω–µ–≥–æ –∫–Ω–æ–ø–∫—É
    for (let i = 0; i < MAX_CHAT_SLOTS; i++) {
        const slotData = userState.slots[i];
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É —Å–ª–æ—Ç–∞ –∫–∞–∫–∞—è-–ª–∏–±–æ –∏—Å—Ç–æ—Ä–∏—è (–≤ –ø–∞–º—è—Ç–∏ –∏–ª–∏ –Ω–∞ –¥–∏—Å–∫–µ)
        const hasHistoryFile = fs.existsSync(getChatHistoryPath(chatId, i));
        const hasInteractions = slotData && slotData.interactions > 0;
        const isUsed = hasHistoryFile || hasInteractions;

        let buttonText = '';

        // –õ–æ–≥–∏–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∫–Ω–æ–ø–∫–µ. –ü–æ—Ä—è–¥–æ–∫ –≤–∞–∂–µ–Ω!
        // 1. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫—É, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ —Å–∞–º—ã–π –∫—Ä–∏—Ç–∏—á–Ω—ã–π —Å—Ç–∞—Ç—É—Å.
        if (slotData.isBanned) {
            // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–µ–π—á–∞—Å –∞–∫—Ç–∏–≤–µ–Ω –≤ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —á–∞—Ç–µ, –ø–æ–º–µ—á–∞–µ–º —ç—Ç–æ —Å—Ç—Ä–µ–ª–∫–æ–π.
            const activeMarker = (i === userState.activeChatSlot) ? '‚û°Ô∏è ' : '';
            // –¢–µ–∫—Å—Ç —á–µ—Ç–∫–æ –≥–æ–≤–æ—Ä–∏—Ç –æ —Å—Ç–∞—Ç—É—Å–µ.
            buttonText = `${activeMarker}–ß–∞—Ç ${i + 1} üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω`;
        
        // 2. –ï—Å–ª–∏ –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ –æ–Ω —Å–µ–π—á–∞—Å.
        } else if (i === userState.activeChatSlot) {
            // –î–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏: —Å—Ç–∞—Ç—É—Å –∏ –≤—Å–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏.
            buttonText = `‚û°Ô∏è –ß–∞—Ç ${i + 1} ‚ú® ‚ù§Ô∏è${slotData.relationshipLevel} ‚õàÔ∏è${slotData.stressLevel}`;
        
        // 3. –ï—Å–ª–∏ –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω, –Ω–æ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω.
        } else if (isUsed) {
            // –î–ª—è "—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ" —á–∞—Ç–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏.
            buttonText = `–ß–∞—Ç ${i + 1} üìÇ ‚ù§Ô∏è${slotData.relationshipLevel} ‚õàÔ∏è${slotData.stressLevel}`;
        
        // 4. –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –∏–∑ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ, –∑–Ω–∞—á–∏—Ç, —Å–ª–æ—Ç –ø—É—Å—Ç.
        } else {
            // –ß–µ—Ç–∫–æ –æ–±–æ–∑–Ω–∞—á–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ª–æ—Ç, –ø—Ä–∏–≥–ª–∞—à–∞—è –Ω–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥.
            buttonText = `–°–ª–æ—Ç ${i + 1} ‚ûï (–ü—É—Å—Ç–æ)`;
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≥–æ—Ç–æ–≤—É—é –∫–Ω–æ–ø–∫—É –≤ –º–∞—Å—Å–∏–≤
        buttons.push([{ text: buttonText, callback_data: `switch_chat_${i}` }]);
    }

    const options = { reply_markup: { inline_keyboard: buttons } };
    await bot.sendMessage(chatId, 'üóÇÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç–µ —á–∞—Ç:', options);
    console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${chatId} –∑–∞–ø—Ä–æ—Å–∏–ª –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π /chatlist`);
});

// --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ú–ï–î–ò–ê ---

async function handleVisualMedia(bot, msg) {
    const chatId = msg.chat.id;
    await bot.sendChatAction(chatId, 'typing');
    
    initializeUser(chatId);
    const userState = userStates[chatId];
    if (!userState) {
        console.error(`–û—à–∏–±–∫–∞: —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${chatId} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`);
        return;
    }
    const activeSlotIndex = userState.activeChatSlot;
    const currentSlotState = userState.slots[activeSlotIndex];
    const currentHistory = chatHistories[chatId][activeSlotIndex];

    try {
        let file_id, mime_type, userPrompt;

        // === –ù–ê–ß–ê–õ–û –ò–ó–ú–ï–ù–ï–ù–ò–ô ===
        if (msg.sticker) {
            if (msg.sticker.is_animated || msg.sticker.is_video) {
                // –î–ª—è –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏ –≤–∏–¥–µ–æ-—Å—Ç–∏–∫–µ—Ä–æ–≤ –±–µ—Ä–µ–º –∏—Ö —Å—Ç–∞—Ç–∏—á–Ω–æ–µ –ø—Ä–µ–≤—å—é (thumbnail)
                if (!msg.sticker.thumbnail) {
                     await bot.sendMessage(chatId, '–£ —ç—Ç–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞ –Ω–µ—Ç –ø—Ä–µ–≤—å—é, –Ω–µ –º–æ–≥—É –µ–≥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å :(');
                     return;
                }
                file_id = msg.sticker.thumbnail.file_id;
                mime_type = 'image/jpeg'; // –ü—Ä–µ–≤—å—é –≤—Å–µ–≥–¥–∞ JPEG
                userPrompt = '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–∏—Å–ª–∞–ª —ç—Ç–æ—Ç –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—Ç–∏–∫–µ—Ä –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ–¥–∞–≤–Ω–∏—Ö —Ä–µ–ø–ª–∏–∫ –∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ —ç—Ç–æ.';
            } else {
                // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Å—Ç–∞—Ç–∏—á–Ω—ã—Ö —Å—Ç–∏–∫–µ—Ä–æ–≤ –±–µ—Ä–µ–º —Å–∞–º —Ñ–∞–π–ª
                file_id = msg.sticker.file_id;
                mime_type = 'image/webp';
                userPrompt = '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–∏—Å–ª–∞–ª —ç—Ç–æ—Ç —Å—Ç–∏–∫–µ—Ä, –æ—Ç–≤–µ—Ç—å –Ω–∞ –Ω–µ–≥–æ —Å–æ–≥–ª–∞—Å–Ω—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É —Å–∏—Ç—É–∞—Ü–∏–∏: –æ–Ω –ø—Ä–∏—Å–ª–∞–ª —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —Ç–∞–∫ –∏–ª–∏ –¥–ª—è –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏—è —Å–∏—Ç—É–∞—Ü–∏–∏?.';
            }
        } else if (msg.photo) {
            file_id = msg.photo[msg.photo.length - 1].file_id;
            mime_type = 'image/jpeg';
            userPrompt = msg.caption || '–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –Ω–µ–¥–∞–≤–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ —ç—Ç–æ —Ñ–æ—Ç–æ, —Ç—ã –∏–º–µ–µ—à—å –ø—Ä–∞–≤–æ –æ–ø–∏—Å–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏–π.';
        } else if (msg.document && msg.document.mime_type.startsWith('image/')) {
            file_id = msg.document.file_id;
            mime_type = msg.document.mime_type;
            userPrompt = msg.caption || '–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –Ω–µ–¥–∞–≤–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ —ç—Ç–æ —Ñ–æ—Ç–æ, —Ç—ã –∏–º–µ–µ—à—å –ø—Ä–∞–≤–æ –æ–ø–∏—Å–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏–π';
        } else {
            return;
        }
        // === –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô ===

        const file = await bot.getFile(file_id);
        if (!file || !file.file_path) {
            throw new Error("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–¥–∞–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö Telegram.");
        }

        const fileUrl = `https://api.telegram.org/file/bot${process.env.TELEGRAM_BOT_TOKEN}/${file.file_path}`;
        const imageResponse = await axios.get(fileUrl, { responseType: 'arraybuffer' });

        if (imageResponse.data.length > 4 * 1024 * 1024) {
            await bot.sendMessage(chatId, "üñºÔ∏è –û–π, —ç—Ç–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –∏–ª–∏ —Å—Ç–∏–∫–µ—Ä —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á—Ç–æ-–Ω–∏–±—É–¥—å –ø–æ–º–µ–Ω—å—à–µ.");
            return;
        }

        const base64Image = Buffer.from(imageResponse.data, 'binary').toString('base64');
        const imagePart = { inlineData: { mimeType: mime_type, data: base64Image } };
        const textPart = { text: userPrompt };

        const contents = currentHistory.map(h => ({ role: h.role === 'assistant' ? 'model' : h.role, parts: h.parts }));
        contents.push({ role: 'user', parts: [textPart, imagePart] });

        if (systemPrompt) {
            contents.unshift({ role: "model", parts: [{ text: `System prompt: ${systemPrompt}` }] });
        }
        
        currentSlotState.interactions++;
        currentSlotState.lastActive = Date.now();

        const model = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME });
        const result = await model.generateContent({ contents });
        const response = await result.response;

        if (!response.candidates?.length) {
            throw new Error("–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç Gemini API");
        }
        
        let responseText = response.candidates[0].content.parts[0].text;
        responseText = extractAndRemoveCommands(responseText, currentSlotState);

        currentHistory.push({ role: 'user', parts: [textPart, imagePart] });
        currentHistory.push({ role: 'model', parts: [{ text: responseText }] });
        saveChatHistory(chatId, activeSlotIndex, currentHistory);
        
        await sendSplitMessage(bot, chatId, responseText, true);
        await sendRelationshipStats(bot, chatId, currentSlotState);

    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ–¥–∏–∞ –¥–ª—è —á–∞—Ç–∞ ${chatId}:`, error.message);
        if (error.response?.data) console.error('Google API response error:', JSON.stringify(error.response.data));
        await bot.sendMessage(chatId, 'üö´ –û–π, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫... –ù–µ –º–æ–≥—É —ç—Ç–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å.');
    }
}

const ffmpeg = require('fluent-ffmpeg');
const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;
ffmpeg.setFfmpegPath(ffmpegPath);

async function handleAnimatedMedia(bot, msg) {
    const chatId = msg.chat.id;
    await bot.sendChatAction(chatId, 'typing');

    initializeUser(chatId);
    const userState = userStates[chatId];
    const activeSlotIndex = userState.activeChatSlot;
    const currentSlotState = userState.slots[activeSlotIndex];
    const currentHistory = chatHistories[chatId][activeSlotIndex];

    const tempInputDir = path.join(__dirname, 'temp_in');
    const tempOutputDir = path.join(__dirname, 'temp_out');
    if (!fs.existsSync(tempInputDir)) fs.mkdirSync(tempInputDir);
    if (!fs.existsSync(tempOutputDir)) fs.mkdirSync(tempOutputDir);
    
    let tempInputPath = '';
    let tempOutputPath = '';

    try {
        let file_id, file_extension, userPrompt;

        // –¢–µ–ø–µ—Ä—å –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ –≥–∏—Ñ–∫–∏ (msg.animation)
        if (msg.animation) {
            file_id = msg.animation.file_id;
            file_extension = 'mp4';
            userPrompt = msg.caption || '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–∏—Å–ª–∞–ª —ç—Ç—É –≥–∏—Ñ–∫—É. –û–ø–∏—à–∏ —Å–≤–æ—é —Ä–µ–∞–∫—Ü–∏—é –Ω–∞ –Ω–µ—ë.';
        } else {
            return; // –ë–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–¥–µ—Å—å
        }
        
        const fileLink = await bot.getFileLink(file_id);
        const response = await axios({ url: fileLink, responseType: 'arraybuffer' });
        const inputBuffer = Buffer.from(response.data);

        const uniqueId = `${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
        tempInputPath = path.join(tempInputDir, `${uniqueId}.${file_extension}`);
        tempOutputPath = path.join(tempOutputDir, `${uniqueId}.png`);
        fs.writeFileSync(tempInputPath, inputBuffer);
        
        await new Promise((resolve, reject) => {
            ffmpeg(tempInputPath)
                .frames(1)
                .output(tempOutputPath)
                .on('end', () => resolve())
                .on('error', (err) => reject(new Error(`–û—à–∏–±–∫–∞ FFMPEG: ${err.message}`)))
                .run();
        });

        if (!fs.existsSync(tempOutputPath)) {
            throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–∞–¥—Ä –∏–∑ –∞–Ω–∏–º–∞—Ü–∏–∏.');
        }

        const imageBuffer = fs.readFileSync(tempOutputPath);
        const base64Image = imageBuffer.toString('base64');
        const imagePart = { inlineData: { mimeType: 'image/png', data: base64Image } };
        const textPart = { text: userPrompt };

        const contents = currentHistory.map(h => ({ role: h.role === 'assistant' ? 'model' : h.role, parts: h.parts }));
        contents.push({ role: 'user', parts: [textPart, imagePart] });

        if (systemPrompt) {
            contents.unshift({ role: "model", parts: [{ text: `System prompt: ${systemPrompt}` }] });
        }
        
        currentSlotState.interactions++;
        currentSlotState.lastActive = Date.now();

        const model = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME });
        const result = await model.generateContent({ contents });
        const genResponse = await result.response;

        if (!genResponse.candidates?.length) {
            throw new Error("–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç Gemini API");
        }
        
        let responseText = genResponse.candidates[0].content.parts[0].text;
        responseText = extractAndRemoveCommands(responseText, currentSlotState);

        currentHistory.push({ role: 'user', parts: [textPart, imagePart] });
        currentHistory.push({ role: 'model', parts: [{ text: responseText }] });
        saveChatHistory(chatId, activeSlotIndex, currentHistory);
        
        await sendSplitMessage(bot, chatId, responseText, true);
        await sendRelationshipStats(bot, chatId, currentSlotState);

    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–µ–¥–∏–∞ –¥–ª—è —á–∞—Ç–∞ ${chatId}:`, error.message);
        await bot.sendMessage(chatId, 'üö´ –£–ø—Å, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫... –ù–µ –º–æ–≥—É —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å —ç—Ç—É –∞–Ω–∏–º–∞—Ü–∏—é.');
    } finally {
        if (tempInputPath && fs.existsSync(tempInputPath)) fs.unlinkSync(tempInputPath);
        if (tempOutputPath && fs.existsSync(tempOutputPath)) fs.unlinkSync(tempOutputPath);
    }
}


// –ù–û–í–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –î–õ–Ø –ì–û–õ–û–°–ê
async function handleVoiceMessage(msg) {
    const chatId = msg.chat.id;

    if (!msg.voice) return;

    try {
        await bot.sendMessage(chatId, 'üéôÔ∏è –°–ª—É—à–∞—é —Ç–≤–æ—ë –ì–°, —Å–µ–∫—É–Ω–¥–æ—á–∫—É...');
        await bot.sendChatAction(chatId, 'typing');

        const fileId = msg.voice.file_id;
        const mimeType = msg.voice.mime_type || 'audio/ogg';

        if (msg.voice.file_size > 14 * 1024 * 1024) { // –õ–∏–º–∏—Ç ~15MB, —Å—Ç–∞–≤–∏–º —Å –∑–∞–ø–∞—Å–æ–º
            await bot.sendMessage(chatId, "–û–π, —ç—Ç–æ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø–∏—Å–∞—Ç—å —á—Ç–æ-–Ω–∏–±—É–¥—å –ø–æ–∫–æ—Ä–æ—á–µ.");
            return;
        }
        
        const fileLink = await bot.getFileLink(fileId);
        const response = await axios({ url: fileLink, responseType: 'arraybuffer' });
        const audioBuffer = Buffer.from(response.data);

        // –í—ã–∑—ã–≤–∞–µ–º –Ω–∞—à –º–æ–¥—É–ª—å –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
        const transcribedText = await transcribeAudio(genAI, audioBuffer, mimeType);

        if (transcribedText && transcribedText.length > 0) {
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ –æ—Å–Ω–æ–≤–Ω—É—é –ª–æ–≥–∏–∫—É –æ–±—Ä–∞–±–æ—Ç–∫–∏
            await processUserText(chatId, transcribedText);
        } else {
            await bot.sendMessage(chatId, '–•–º, –Ω–µ –º–æ–≥—É —Ä–∞–∑–æ–±—Ä–∞—Ç—å, —á—ë —Ç—ã –≤—è–∫–Ω—É–ª. –ü–æ–ø—Ä–æ–±—É–π –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç–æ–º.');
        }

    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —á–∞—Ç–∞ ${chatId}:`, error.message);
        await bot.sendMessage(chatId, 'üö´ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
    }
}// –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø –î–õ–Ø –ó–ê–ú–ï–ù–´
async function handleVoiceMessage(msg) {
    const chatId = msg.chat.id;

    if (!msg.voice) return;

    try {
        await bot.sendMessage(chatId, 'üéôÔ∏è –°–ª—É—à–∞—é —Ç–≤–æ—ë –ì–°, —Å–µ–∫—É–Ω–¥–æ—á–∫—É...');
        await bot.sendChatAction(chatId, 'typing');

        const fileId = msg.voice.file_id;
        const mimeType = msg.voice.mime_type || 'audio/ogg';

        if (msg.voice.file_size > 14 * 1024 * 1024) { // –õ–∏–º–∏—Ç ~15MB, —Å—Ç–∞–≤–∏–º —Å –∑–∞–ø–∞—Å–æ–º
            await bot.sendMessage(chatId, "–û–π, —ç—Ç–æ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø–∏—Å–∞—Ç—å —á—Ç–æ-–Ω–∏–±—É–¥—å –ø–æ–∫–æ—Ä–æ—á–µ.");
            return;
        }
        
        const fileLink = await bot.getFileLink(fileId);
        const response = await axios({ url: fileLink, responseType: 'arraybuffer' });
        const audioBuffer = Buffer.from(response.data);

        // –í—ã–∑—ã–≤–∞–µ–º –Ω–∞—à –º–æ–¥—É–ª—å –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
        const transcribedText = await transcribeAudio(genAI, audioBuffer, mimeType);

        if (transcribedText && transcribedText.length > 0) {
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∏ ID –û–†–ò–ì–ò–ù–ê–õ–¨–ù–û–ì–û –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            await processUserText(chatId, transcribedText, msg.message_id);
        } else {
            await bot.sendMessage(chatId, '–•–º, –Ω–µ –º–æ–≥—É —Ä–∞–∑–æ–±—Ä–∞—Ç—å, —á—ë —Ç—ã –≤—è–∫–Ω—É–ª. –ü–æ–ø—Ä–æ–±—É–π –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç–æ–º.');
        }

    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —á–∞—Ç–∞ ${chatId}:`, error.message);
        await bot.sendMessage(chatId, 'üö´ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
    }
}

// –ù–û–í–ê–Ø –û–ë–©–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –û–ë–†–ê–ë–û–¢–ö–ò –¢–ï–ö–°–¢–ê
// –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø –î–õ–Ø –ó–ê–ú–ï–ù–´
async function processUserText(chatId, userInput, replyToMessageId) {
    const userState = userStates[chatId];
    const activeSlotIndex = userState.activeChatSlot;
    const currentSlotState = userState.slots[activeSlotIndex];

    if (currentSlotState.isBanned) {
        try {
            await bot.sendMessage(chatId, "–ù—É-–Ω—É, –∫–∞–∂–µ—Ç—Å—è –ì–æ—Ä–µ–ø–æ—á–∫–∞ —É—Å—Ç–∞–ª–∞ –æ—Ç –≤–∞—à–µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è –∏ –±–ª–æ–∫–Ω—É–ª–∞ –≤–∞—Å. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /clear –∏–ª–∏ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç–µ—Å—å –Ω–∞ –Ω–æ–≤—ã–π —á–∞—Ç.");
        } catch (error) {
             console.error(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –±–∞–Ω–µ (${chatId}):`, error.message);
        }
        return;
    }

    if (chatHistories[chatId][activeSlotIndex].length === 0 && fs.existsSync(getChatHistoryPath(chatId, activeSlotIndex))) {
        chatHistories[chatId][activeSlotIndex] = loadChatHistory(chatId, activeSlotIndex);
    }
    const currentHistory = chatHistories[chatId][activeSlotIndex];

    currentSlotState.spamCounter++;
    if (currentSlotState.spamCounter > 2) {
        try {
            await bot.sendMessage(chatId, '–û–π-–æ–π —Å–ø–∞–º–∏—Ç—å - –Ω–µ —Ö–æ—Ä–æ—à–æ! üò† –ü–æ–¥–æ–∂–¥–∏, –∫–æ–≥–¥–∞ —è –¥–æ–≥–æ–≤–æ—Ä—é.');
        } catch (error) { /* ignore */ }
        return;
    }

    currentHistory.push({ role: "user", parts: [{ text: userInput }] });
    currentSlotState.interactions++;
    currentSlotState.lastActive = Date.now();

    try {
        await bot.sendChatAction(chatId, 'typing');

        const contents = currentHistory.map(msg => ({ role: msg.role === "assistant" ? "model" : msg.role, parts: msg.parts }));
        if (systemPrompt) {
            contents.unshift({ role: "model", parts: [{ text: `System prompt: ${systemPrompt}` }] });
        }

        const model = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME });
        const result = await model.generateContent({ contents });
        const response = await result.response;

        if (!response.candidates?.length) throw new Error("–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç Gemini API");

        let botResponse = response.candidates[0].content.parts[0].text;
        botResponse = extractAndRemoveCommands(botResponse, currentSlotState);

        currentHistory.push({ role: "model", parts: [{ text: botResponse }] });
        saveChatHistory(chatId, activeSlotIndex, currentHistory);

        currentSlotState.contextSize = currentHistory.length;
        if (currentHistory.length > 100) {
            currentHistory.splice(0, currentHistory.length - 80);
            saveChatHistory(chatId, activeSlotIndex, currentHistory);
            console.log(`–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–∞ ${chatId} —Å–æ–∫—Ä–∞—â–µ–Ω–∞.`);
        }

        // –ü–µ—Ä–µ–¥–∞–µ–º ID –¥–∞–ª—å—à–µ –≤ —Ñ—É–Ω–∫—Ü–∏—é –æ—Ç–ø—Ä–∞–≤–∫–∏
        await sendSplitMessage(bot, chatId, botResponse, true, replyToMessageId);
        
        currentSlotState.spamCounter = 0;
        await sendRelationshipStats(bot, chatId, currentSlotState);

    } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –±–æ—Ç–æ–º:`, error.message, error.stack);
        await bot.sendMessage(chatId, 'üö´ –û–π, —É –º–µ–Ω—è –∫–∞–∂–µ—Ç—Å—è –≥–æ–ª–æ–≤–∞ —Ä–∞–∑–±–æ–ª–µ–ª–∞—Å—å... –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑ —á—É—Ç—å –ø–æ–∑–∂–µ. –ö–æ–º–∞–Ω–¥–∞ /clear –º–æ–∂–µ—Ç –ø–æ–º–æ—á—å.');
        currentSlotState.spamCounter = 0;
    }
}


// –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø –î–õ–Ø –ó–ê–ú–ï–ù–´
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    initializeUser(chatId);

    if (msg.animation) {
        if (!userStates[chatId].hasCompletedWelcome) {
            await showWelcomeMessage(chatId);
            return;
        }
        await handleAnimatedMedia(bot, msg);
        return;
    }

    if (msg.photo || (msg.document && msg.document.mime_type.startsWith('image/')) || msg.sticker) {
        if (!userStates[chatId].hasCompletedWelcome) {
            await showWelcomeMessage(chatId);
            return;
        }
        await handleVisualMedia(bot, msg);
        return;
    }
    
    if (msg.voice) {
        if (!userStates[chatId].hasCompletedWelcome) {
            await showWelcomeMessage(chatId);
            return;
        }
        await handleVoiceMessage(msg);
        return;
    }

    const userInput = msg.text;
    if (!userInput) return; 

    if (!(await isChatValid(chatId))) return;

    if (userInput.startsWith('/')) {
        if (['/start', '/chatlist'].includes(userInput)) return; 
        if (userInput === '/clear') {
            const activeSlotIndex = userStates[chatId].activeChatSlot;
            clearChatHistoryAndState(chatId, activeSlotIndex);
            await bot.sendMessage(chatId, `–ß–∞—Ç ${activeSlotIndex + 1} –æ—á–∏—â–µ–Ω üóëÔ∏è.`);
            return;
        }
        if (userInput === '/context') {
            const activeSlotIndex = userStates[chatId].activeChatSlot;
            const filePath = getChatHistoryPath(chatId, activeSlotIndex);
            if (fs.existsSync(filePath)) await bot.sendDocument(chatId, fs.createReadStream(filePath));
            else await bot.sendMessage(chatId, `–ö–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —á–∞—Ç–∞ ${activeSlotIndex + 1} –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.`);
            return;
        }
        if (userInput === '/changes') {
            try {
                const changelog = fs.readFileSync(CHANGELOG_PATH, 'utf8');
                await sendSplitMessage(bot, chatId, `üìÑ –ü–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:\n${changelog}`, false);
            } catch (error) { await bot.sendMessage(chatId, '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π.'); }
            return;
        }
        return;
    }
    
    if (!userStates[chatId].hasCompletedWelcome) {
        await showWelcomeMessage(chatId);
        return;
    }

    // –í—ã–∑—ã–≤–∞–µ–º –Ω–∞—à—É –æ–±—â—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞, –ø–µ—Ä–µ–¥–∞–≤–∞—è ID —Å–æ–æ–±—â–µ–Ω–∏—è
    await processUserText(chatId, userInput, msg.message_id);
});


// –ü–û–õ–ù–ê–Ø –í–ï–†–°–ò–Ø –î–õ–Ø –ó–ê–ú–ï–ù–´
async function sendSplitMessage(bot, chatId, originalText, isAiResponseType, replyToMessageId) {
    let typingTimer;
    const startTyping = async () => {
        if (typingTimer) clearInterval(typingTimer);
        try {
            if (await isChatValid(chatId)) {
                await bot.sendChatAction(chatId, 'typing');
                typingTimer = setInterval(async () => {
                    try {
                        if (await isChatValid(chatId)) { await bot.sendChatAction(chatId, 'typing'); }
                        else { stopTyping(); }
                    } catch { stopTyping(); }
                }, 4000);
            }
        } catch { /* ignore */ }
    };
    const stopTyping = () => {
        if (typingTimer) { clearInterval(typingTimer); typingTimer = null; }
    };
    await startTyping();

    const messageIds = [];
    let isFirstChunk = true;

    try {
        if (!(await isChatValid(chatId))) { stopTyping(); return []; }

        const createMessageOptions = (textChunk) => {
            const options = { parse_mode: 'Markdown' };
            if (isFirstChunk && replyToMessageId && isAiResponseType && !textChunk.trim().startsWith('```')) {
                options.reply_to_message_id = replyToMessageId;
            }
            return options;
        };
        
        const sendMessageAndUpdateFlag = async (textChunk) => {
            if (!(await isChatValid(chatId))) return null;
            if (!textChunk || !textChunk.trim()) return null; 

            const options = createMessageOptions(textChunk);
            const sent = await bot.sendMessage(chatId, textChunk, options);
            isFirstChunk = false;
            return sent;
        };

        if (!isAiResponseType) {
            if (originalText.length <= 4096) {
                const sent = await sendMessageAndUpdateFlag(originalText);
                if(sent) messageIds.push(sent.message_id);
            } else {
                const chunks = originalText.match(/([\s\S]|[\r\n]){1,4096}/g) || [];
                for (const chunk of chunks) {
                    const sent = await sendMessageAndUpdateFlag(chunk);
                    if(sent) messageIds.push(sent.message_id);
                    await new Promise(resolve => setTimeout(resolve, 700));
                }
            }
            stopTyping();
            return messageIds;
        }

        if (originalText.length <= 85) {
            const partsForShortAi = originalText.split(/(```[\s\S]*?```)/gs);
            for (const part of partsForShortAi) {
                if(part.trim()){
                    const sent = await sendMessageAndUpdateFlag(part);
                    if(sent) messageIds.push(sent.message_id);
                }
            }
            stopTyping();
            return messageIds;
        }

        let zerosSentThisMessage = 0;
        let onesSentThisMessage = 0;
        const textAndCodeParts = originalText.split(/(```[\s\S]*?```)/gs);
        let currentMessageSegment = '';
        let punctuationEventsInCurrentTextSegment = 0;

        for (const part of textAndCodeParts) {
            if (!(await isChatValid(chatId))) { stopTyping(); return messageIds; }
            if (part.startsWith('```') && part.endsWith('```')) {
                if (currentMessageSegment.trim()) {
                    const sent = await sendMessageAndUpdateFlag(currentMessageSegment.trim());
                    if (sent) messageIds.push(sent.message_id);
                    currentMessageSegment = '';
                    punctuationEventsInCurrentTextSegment = 0;
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                if (part.length <= 4096) {
                    const sent = await sendMessageAndUpdateFlag(part);
                    if (sent) messageIds.push(sent.message_id);
                } else {
                    const codeChunks = part.match(/([\s\S]|[\r\n]){1,4090}/g) || [];
                    for (let k = 0; k < codeChunks.length; k++) {
                        if (!(await isChatValid(chatId))) { stopTyping(); return messageIds; }
                        let chunkToSend = codeChunks[k];
                        if (k === 0 && !chunkToSend.startsWith("```")) chunkToSend = "```\n" + chunkToSend;
                        if (k === codeChunks.length - 1 && !chunkToSend.endsWith("```")) chunkToSend = chunkToSend + "\n```";
                        const sent = await sendMessageAndUpdateFlag(chunkToSend);
                        if (sent) messageIds.push(sent.message_id);
                        await new Promise(resolve => setTimeout(resolve, 700));
                    }
                }
                punctuationEventsInCurrentTextSegment = 0;
            } else {
                for (let i = 0; i < part.length; i++) {
                    const char = part[i];
                    currentMessageSegment += char;
                    let eventType = null;
                    if (char === '.' && i + 2 < part.length && part[i + 1] === '.' && part[i + 2] === '.') {
                        eventType = 'ellipsis';
                        currentMessageSegment += part[i + 1] + part[i + 2];
                        i += 2; 
                    } else if (char === '.' || char === '?' || char === '!') {
                        eventType = 'punctuation';
                    }

                    if (eventType) {
                        punctuationEventsInCurrentTextSegment++;
                        if (punctuationEventsInCurrentTextSegment >= 2) {
                            let makeSplitDecision = false;
                            const canSplit = onesSentThisMessage < 3;
                            if (canSplit && Math.random() > 0.5) {
                                makeSplitDecision = true;
                            }

                            if (makeSplitDecision) {
                                if (currentMessageSegment.trim()) {
                                    const sent = await sendMessageAndUpdateFlag(currentMessageSegment.trim());
                                    if (sent) messageIds.push(sent.message_id);
                                }
                                currentMessageSegment = '';
                                onesSentThisMessage++;
                                zerosSentThisMessage = 0; 
                                punctuationEventsInCurrentTextSegment = 0;
                                await startTyping();
                                const delay = Math.random() * (3700 - 990) + 990;
                                await new Promise(resolve => setTimeout(resolve, Math.floor(delay)));
                            } else {
                                zerosSentThisMessage++;
                            }
                        }
                    }
                    if (currentMessageSegment.length >= 4050) {
                        if (!(await isChatValid(chatId))) { stopTyping(); return messageIds; }
                        const sent = await sendMessageAndUpdateFlag(currentMessageSegment.trim());
                        if (sent) messageIds.push(sent.message_id);
                        currentMessageSegment = '';
                        punctuationEventsInCurrentTextSegment = 0;
                        await startTyping();
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }
            }
        }
        if (currentMessageSegment.trim()) {
            if (!(await isChatValid(chatId))) { stopTyping(); return messageIds; }
            const sent = await sendMessageAndUpdateFlag(currentMessageSegment.trim());
            if (sent) messageIds.push(sent.message_id);
        }
        stopTyping();
        return messageIds;
    } catch (error) {
        stopTyping();
        if (error.response?.body?.error_code === 403) {
            console.error(`‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${chatId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.`);
            if (userStates[chatId]) delete userStates[chatId];
            if (chatHistories[chatId]) delete chatHistories[chatId];
            return [];
        }
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:', error.message, error.stack);
        try {
            if (await isChatValid(chatId)) {
                await bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ üö´ –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç.');
            }
        } catch (sendError) {
            console.error(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ (${chatId}):`, sendError.message);
        }
        return messageIds;
    }
}

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`üöÄ –°–µ—Ä–≤–µ—Ä Node.js –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
    console.log(`‚ÑπÔ∏è URL –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏: http://localhost:${PORT}`);
});

bot.on('polling_error', (error) => {
    console.error(`‚ùå –û—à–∏–±–∫–∞ polling'–∞ Telegram: ${error.code} - ${error.message}`);
});

bot.on('webhook_error', (error) => {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–µ–±—Ö—É–∫–∞: ${error.message}`);
});

console.log('‚ÑπÔ∏è –ë–æ—Ç –ì–æ—Ä–µ–ø–æ—á–∫–∞ –æ–∂–∏–¥–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã...');..');